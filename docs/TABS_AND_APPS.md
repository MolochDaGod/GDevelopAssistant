# Tabs, Apps, and Project Organization

This repo hosts multiple games/tools as "tabs" in one platform. Each tab has a unique slug, source, assets, and packaging metadata. This guide defines the structure and the process to add or update tabs and apps.

## Slugs
- Lowercase, kebab-case (letters, numbers, dashes). Examples: `grudge-swarm`, `sprite-lab`, `crafting-suite`.
- Slug becomes the URL path: `/{slug}`

## Directory Layout
```
apps/                    # per-tab packaging & metadata (non-code)
  <slug>/
    tab.config.json      # metadata (title, routes, assets)
    README.md

client/
  src/
    tabs/
      <slug>/           # tab UI/logic entry (index.tsx)
    tabs.registry.json  # list of tabs: [{ slug, title, entry }]

attached_assets/
  tabs/
    <slug>/
      sprites/          # images from Drive (synced into /assets/<slug>/sprites)
      models/           # 3D assets from Drive (synced into /assets/<slug>/models)

client/public/assets/    # build output (generated by asset:sync)
  manifest.json
  <category>/...
  <slug>/sprites/...     # per-tab sprites
  <slug>/models/...      # per-tab models
```

## Asset Pipeline
- Source of truth: Google Drive folder (`DRIVE_FOLDER_ID`)
- CI (or local) runs:
  1. `npm run asset:drive:sync`  → downloads Drive → `attached_assets/drive` (and `attached_assets/tabs/<slug>` if organized that way)
  2. `npm run asset:sync`        → copies and normalizes assets to `client/public/assets`
- Per-tab grouping: If a file path contains `tabs/<slug>/...` it will be grouped under `/assets/<slug>/...` automatically.
- Sprite loader base URL: `/assets`

## Adding a New Tab/App
1. Pick a slug: `my-tab`
2. Scaffold
   ```sh
   npm run scaffold:tab my-tab "My Tab Title"
   ```
   This creates:
   - `apps/my-tab/tab.config.json`
   - `client/src/tabs/my-tab/index.tsx`
   - `attached_assets/tabs/my-tab/{sprites,models}`
   - Adds to `client/src/tabs.registry.json`
3. Put assets into Drive under a per-tab folder, or locally under `attached_assets/tabs/my-tab/` (sprites/models).
4. Build & run:
   ```sh
   npm run asset:drive:sync   # optional, if using Drive locally
   npm run asset:sync
   npm run build
   vercel --prod
   ```

## Best Practices
- Naming: kebab-case; avoid spaces. If legacy assets have spaces, the loader encodes them, but prefer `archer-idle-01.png`.
- Caching: Vercel serves static assets with HTTP caching. We can add content hashing later; for now, version assets in `apps/<slug>/tab.config.json`.
- Sprites vs Sheets: Use single images per state to start. Move to spritesheets + JSON (TexturePacker or Lottie) when stable to reduce requests.
- Models: Prefer GLB. Optimize with `gltfpack` or `gltf-transform` before upload.
- Env Vars: Per project, keep URLs/keys out of client; store in Vercel env. If a tab needs server env, add a server adapter and map variables in `tab.config.json`.
- Downloads: Each tab can publish a downloadable bundle (assets + config) from `apps/<slug>`. A future script can zip `client/public/assets/<slug>` + `apps/<slug>/tab.config.json`.

## Definitions (Glossary)
- Tab: A top-level feature/game/tool surfaced in the UI, addressed by a slug.
- App: A fuller product composed of multiple tabs and/or services.
- Registry: `client/src/tabs.registry.json` tells the UI what tabs exist and their entry points.

## Future Automation (Optional)
- Router/Sidebar: Generate navigation and routes from `tabs.registry.json`.
- Packager: `scripts/package-tab.mjs <slug>` → zip assets + config for distribution.
- Content Hashing: Update `asset:sync` to write hashed filenames and a map for runtime resolution.
- Sprite Atlases: Add an atlas generator step.
